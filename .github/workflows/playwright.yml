name: Playwright E2E

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      db:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: gamo_dev
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U postgres" --health-interval=10s --health-timeout=5s --health-retries=5
    env:
      # Vari√°veis da API
      # Use local postgres service container for tests instead of production DB
      DATABASE_URL: postgresql://postgres:postgres@localhost:5432/gamo_dev?sslmode=disable
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
      SMTP_HOST: ${{ secrets.SMTP_HOST }}
      SMTP_PORT: ${{ secrets.SMTP_PORT }}
      SMTP_USER: ${{ secrets.SMTP_USER }}
      SMTP_PASS: ${{ secrets.SMTP_PASS }}
      SMTP_FROM: ${{ secrets.SMTP_FROM }}
      SENDINBLUE_API_KEY: ${{ secrets.SENDINBLUE_API_KEY }}
      CLOUDINARY_CLOUD_NAME: ${{ secrets.CLOUDINARY_CLOUD_NAME }}
      CLOUDINARY_API_KEY: ${{ secrets.CLOUDINARY_API_KEY }}
      CLOUDINARY_API_SECRET: ${{ secrets.CLOUDINARY_API_SECRET }}
      ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
      ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
      FRONTEND_URL: http://localhost:3000
      NEXT_PUBLIC_API_URL: http://localhost:8080
      RAWG_API_KEY: ${{ secrets.RAWG_API_KEY }}
      STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
      NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}

      # Vari√°veis do Firebase para o frontend
      NEXT_PUBLIC_FIREBASE_API_KEY: ${{ secrets.NEXT_PUBLIC_FIREBASE_API_KEY }}
      NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN: ${{ secrets.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN }}
      NEXT_PUBLIC_FIREBASE_PROJECT_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_PROJECT_ID }}
      NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET: ${{ secrets.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET }}
      NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID }}
      NEXT_PUBLIC_FIREBASE_APP_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_APP_ID }}
    steps:
      - uses: actions/checkout@v4

      # Clona a API (ajuste o reposit√≥rio e branch conforme necess√°rio)
      - name: Checkout API
        uses: actions/checkout@v4
        with:
          repository: mateusbatatais/gamo-api
          path: api

      # Builda e sobe a API
      - name: Build API Docker image
        run: docker build --build-arg DATABASE_URL="${DATABASE_URL}" -t gamo-api ./api

      - name: Run API container
        run: |
          docker run -d --name api \
            -e DATABASE_URL \
            -e JWT_SECRET \
            -e FIREBASE_SERVICE_ACCOUNT \
            -e SMTP_HOST \
            -e SMTP_PORT \
            -e SMTP_USER \
            -e SMTP_PASS \
            -e SMTP_FROM \
            -e SENDINBLUE_API_KEY \
            -e CLOUDINARY_CLOUD_NAME \
            -e CLOUDINARY_API_KEY \
            -e CLOUDINARY_API_SECRET \
            -e ADMIN_EMAIL \
            -e ADMIN_PASSWORD \
            -e FRONTEND_URL \
            -e STRIPE_SECRET_KEY \
            -e RAWG_API_KEY \
            -e PORT=8080 \
            --network host \
            -p 8080:8080 gamo-api

      # Verifica status do container
      - name: Check API container status
        run: |
          echo "Container status:"
          docker ps -a | grep api || true
          echo "\nContainer logs (last 50 lines):"
          docker logs --tail 50 api || true

      # Espera a API subir
      - name: Wait for API
        run: |
          for i in {1..30}; do
            if curl -s http://localhost:8080/health; then
              echo "API is up!";
              exit 0;
            fi
            echo "Waiting for API...";
            sleep 2;
          done
          echo "API did not start in time";
          echo "\nFinal container status:"
          docker ps -a | grep api || true
          docker ps -a | grep api || true
          exit 1

      # Seed Database with Test User
      - name: Seed Test User
        run: |
          echo "üå± Seeding Admin User..."

          # Signup via API
          response=$(curl -s -w "\n%{http_code}" -X POST http://localhost:8080/api/auth/signup \
            -H "Content-Type: application/json" \
            -d "{\"name\": \"Admin E2E\", \"email\": \"$ADMIN_EMAIL\", \"password\": \"$ADMIN_PASSWORD\", \"locale\": \"en\"}")
            
          http_code=$(echo "$response" | tail -n1)
          echo "Signup response: $response"

          if [ "$http_code" -eq 201 ] || [ "$http_code" -eq 200 ] || [ "$http_code" -eq 409 ]; then
             echo "‚úÖ User seeded or already exists."
          else
             echo "‚ö†Ô∏è User seeding returned $http_code. Tests might fail."
          fi

          # Verify User via SQL (Bypass email verification if needed)
          echo "üîß Verifying user email in DB..."
          docker run --network host --rm --env PGPASSWORD=postgres postgres:15-alpine \
            psql -h localhost -U postgres -d gamo_dev \
            -c "UPDATE \"User\" SET \"emailVerified\" = NOW(), \"hasPassword\" = true WHERE email = '$ADMIN_EMAIL';" || echo "SQL Update failed (User might not exist or table name mismatch)"

      - name: Show full API logs if failed
        if: failure()
        run: |
          echo "Full API logs:"
          docker logs api || true
          echo "\nContainer inspect:"
          docker inspect api || true

      # Instala depend√™ncias do frontend
      - name: Install dependencies
        run: npm install -g pnpm && pnpm install

      # Build and start the Next.js frontend (required for Playwright)
      - name: Build Frontend
        run: |
          pnpm run build
      - name: Start Frontend Server
        run: |
          pnpm start &
          # Wait until the server is reachable
          for i in {1..30}; do
            if curl -s http://localhost:3000/health || curl -s http://localhost:3000/api/health; then
              echo "Frontend is up!"; break;
            fi
            echo "Waiting for frontend..."; sleep 2;
          done

      - name: Get Playwright Version
        id: playwright-version
        run: |
          PLAYWRIGHT_VERSION=$(pnpm list @playwright/test --depth=0 | grep @playwright/test | awk '{print $2}')
          echo "PLAYWRIGHT_VERSION=$PLAYWRIGHT_VERSION" >> $GITHUB_ENV

      - name: Cache Playwright Binaries
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: |
            ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ env.PLAYWRIGHT_VERSION }}

      # Instala browsers do Playwright (apenas se n√£o estiver em cache ou parcialmente)
      - name: Install Playwright Browsers
        run: pnpm exec playwright install --with-deps
        if: steps.playwright-cache.outputs.cache-hit != 'true'
      - name: Install Playwright Deps (Fallback)
        run: pnpm exec playwright install-deps
        if: steps.playwright-cache.outputs.cache-hit == 'true'

      # Roda os testes E2E
      - name: Run Playwright tests
        run: pnpm exec playwright test

      # Salva artefatos de debug
      - uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: playwright-debug
          path: |
            playwright-report/
            tests/e2e/login-page.html
            tests/e2e/login-after-submit.png
            tests/e2e/login-after-submit.html
          retention-days: 7
